package dev.brighten.anticheat.check.impl.packet.exploits;

import cc.funkemunky.api.Atlas;
import cc.funkemunky.api.bungee.BungeeAPI;
import cc.funkemunky.api.com.github.retrooper.packetevents.event.PacketReceiveEvent;
import cc.funkemunky.api.com.github.retrooper.packetevents.protocol.packettype.PacketType;
import cc.funkemunky.api.com.github.retrooper.packetevents.protocol.packettype.PacketTypeCommon;
import cc.funkemunky.api.com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerPlayerPositionAndLook;
import cc.funkemunky.api.com.github.retrooper.packetevents.wrapper.play.server.WrapperPlayServerPluginMessage;
import cc.funkemunky.api.utils.MiscUtils;
import cc.funkemunky.api.utils.RunUtils;
import dev.brighten.anticheat.check.api.*;
import dev.brighten.api.check.CheckType;
import lombok.AllArgsConstructor;
import lombok.NoArgsConstructor;
import org.bukkit.entity.Player;

import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@CheckInfo(name = "PacketSpam", description = "Prevents the spam of packets.",
        checkType = CheckType.EXPLOIT, punishVL = 30, executable = false)
public class PacketSpam extends Check {

    @Setting(name = "whitelistedPackets")
    private static List<String> whitelistedPackets = Arrays.asList(PacketType.Play.Client.CHAT_MESSAGE.name(),
            PacketType.Play.Client.CLICK_WINDOW.name(), PacketType.Play.Client.PONG.name(),
            PacketType.Play.Client.CREATIVE_INVENTORY_ACTION.name(), PacketType.Play.Client.WINDOW_CONFIRMATION.name(),
            PacketType.Play.Client.KEEP_ALIVE.name());

    private Map<PacketTypeCommon, PacketTicks> packetsMap = new HashMap<>();

    @Setting(name = "thresholds.payloadBase")
    private static int payloadThresholdBase = 25;

    @Setting(name = "thresholds.generalBase")
    private static int generalThresholdBase = 80;

    @Setting(name = "disconnectChannel")
    private static boolean disconnectChannel = true;

    @Packet
    public void onSend(WrapperPlayServerPluginMessage packet, long timeStamp) {
        PacketTicks packets = packetsMap.getOrDefault(PacketType.Play.Client.PLUGIN_MESSAGE,
                new PacketTicks(0, timeStamp));

        packets.ticks--;

        packetsMap.put(PacketType.Play.Client.PLUGIN_MESSAGE, packets);
    }

    @Packet
    public void onPosition(WrapperPlayServerPlayerPositionAndLook packet, long timeStamp) {
        PacketTicks packets = packetsMap.getOrDefault(PacketType.Play.Client.PLAYER_FLYING,
                new PacketTicks(0, timeStamp));

        packets.ticks--;

        packetsMap.put(PacketType.Play.Client.PLAYER_FLYING, packets);
    }

    @Event
    public boolean onReceive(PacketReceiveEvent event) {
        if(whitelistedPackets.contains(event.getPacketType().getName())
                || event.getTimestamp() - data.creation < 1000) return false;

        PacketTicks packets = packetsMap.getOrDefault(MiscUtils.isFlying(event.getPacketType())
                        ? PacketType.Play.Client.PLAYER_FLYING : event.getPacketType(),
                new PacketTicks(0, event.getTimestamp()));

        boolean cancelled = false;
        if(event.getTimestamp() - packets.lastReset <= 200) {
            int thresholdBase = event.getPacketType().equals(PacketType.Play.Client.PLUGIN_MESSAGE)
                    ? payloadThresholdBase : generalThresholdBase;
            if(++packets.ticks > thresholdBase) {
                vl++;
                flag(true, "ticks=" + packets.ticks + " packet=" + event.getPacketType().getName());
                if(packets.ticks > thresholdBase * 2) {
                    if(disconnectChannel)
                    closePlayerChannel();
                    else kickPlayer(data.getPlayer());
                }
                cancelled = true;
            } else if(packets.ticks > 5) {
                debug("type=%s ticks=%s", event.getPacketType().getName(), packets.ticks);
            }
        } else {
            packets.ticks = 0;
            packets.lastReset = event.getTimestamp();
        }
        packetsMap.put(event.getPacketType(), packets);
        return cancelled;
    }

    private static void kickPlayer(Player player) {
        if(Atlas.getInstance().getBungeeManager().isBungee()) {
            BungeeAPI.kickPlayer(player.getUniqueId(), "Too many packets");
        } else RunUtils.task(() -> player.kickPlayer("Too many packets"));
    }

    @AllArgsConstructor
    @NoArgsConstructor
    public class PacketTicks {
        public int ticks;
        public long lastReset;
    }
}
